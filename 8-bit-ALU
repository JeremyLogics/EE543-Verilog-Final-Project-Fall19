/*

**The control signal corresponds directly to the encoding of instruction set architecture (ISA) P37X and ARM ISA.

**If any control signal other those specified is given to the ALU, the ALU should set all 8 output bits to zero.

**The NOT operation returns the logical inverse of the second ALU input (input2), and it ignores the first input (input1).

**The SUB operation computes output = input1 - input2.

**The RSB operation computes output = input2 - input1.

**For the MUL operations, the four higher bits of input1 and the four higher bits of input2 will perform multiplication (i.e. 4 MSBs perform multiplication).

**For the shift operations, input1 is the value to be shifted and the three lower bits of input2 
determine the amount of the shift (0 to 7 binary digits). For example, if input1 = 8’b10001111 
and input2 = 8’b1110010, for the instruction SRL, we shift input1 to the right by 2 bits, so the result is 8’b00100011.

**For the rotate operations, input1 is the value to be rotated and the three lower 
bits of input2 determine the amount of the rotation (0 to 7 binary digits). 
For example, if input1 = 8’b10001111 and input2 = 8’b1110010, for the instruction ROR,
we rotate input1 to the right by 2 bits, so the result is 8’b11100011.


**Implementation: The ALU should instantiate a single 8-bit adder (also used for subtraction, 
feel free to use the design from our lectures or homework), a 4-bit multiplier (from Part 1), 
logical gates, a left shifter, a right shifter, a left rotator, and a right rotator module. 
Using the outputs from these modules and some combinational logic to generate all 12 possible values. 
Finally, use a multiplexer to select the correct output.

*/

//Top ALU Module, unused control signals output 0000 0000
module JLapane_8_bit_ALU
	(
    input_a_top,    // first input
    input_b_top,    // second input
	control,        // selects function desired
    output_top,     // output from ALU, muxed using 8 of the 8-to-1 mux module.
    carry_out_top   // carry out output
	);
input   [3:0]   control;
input   [7:0]   input_a_top, input_b_top;

output  [7:0]   output_top;
output          carry_out_top;

wire            carry_out_add, carry_out_sub, carry_out_rsb;
//these wires map from arithmetic or logical modules to 8 mux16 inputs
wire    [7:0]   add_out, 
                sub_out,
                rsb_out,
                mul_out,
                nor_out,
                not_out,
                nand_out,
                xnor_out,
                srl_out,
                sll_out,
                ror_out,
                rol_out
                ;

// todo create mux for carry_out_top and FADDSUB8 carry outs

// control 0000 unused, unused control signals output 0000 0000



// control 0001 ADD S = A + B (if sel is 2'b01, sum = a+b; 2'b10, sum = a-b, 2'b11, sum = b-a.)
FADDSUB8 ADD_top (input_a_top, input_b_top, add_out, 2'b01, carry_out_add);

// control 0010 SUB S = A - B (if sel is 2'b01, sum = a+b; 2'b10, sum = a-b, 2'b11, sum = b-a.)
FADDSUB8 SUB_top (input_a_top, input_b_top, sub_out, 2'b10, carry_out_sub);

// control 0011 SUB S = A - B (if sel is 2'b01, sum = a+b; 2'b10, sum = a-b, 2'b11, sum = b-a.)
FADDSUB8 RSB_top (input_a_top, input_b_top, rsb_out, 2'b11, carry_out_rsb);


// control 0100 MUL S [7:0] = A [7:4] * B [7:4]
JLAPANEMUL4 MUL_top (input_a_top,  input_b_top, mul_out);



// control 0101 not used, unused control signals output 0000 0000
// control 0110 not used, unused control signals output 0000 0000
// control 0111 not used, unused control signals output 0000 0000



// control 1000 bitwise NOR: module NOR8 (input_a, input_b, output_ab_nor);
myNOR8 NOR_top    (input_a_top, input_b_top, nor_out);

// control 1001 bitwise NOT: module NOT8 (input_b, output_b_NOT);
myNOT8 NOT_top    (input_b_top, not_out);

// control 1010 bitwise NAND: module NAND8 (input_a, input_b, output_ab_nand);
myNAND8 NAND_top  (input_a_top, input_b_top, nand_out);

// control 1011 bitwise XNOR: module XNOR8 (input_a, input_b, output_ab_xnor);
myXNOR8 XNOR_top  (input_a_top, input_b_top, xnor_out);

// control 1100 shift right logical: module Shift_Right (input_a, input_b, output_a_shifted);
Shift_Right SRL_top (input_a_top, input_b_top, srl_out);

// control 1101 shift left logical: module Shift_Left (input_a, input_b, output_a_shifted_left);
Shift_Left SLL_top  (input_a_top, input_b_top, sll_out);

// control 1110 rotate right: module Rotate_Right (input_a, input_b, output_a_rotated_right);
Rotate_Right ROR_top (input_a_top, input_b_top, ror_out);

// control 1111 rotate left: module Rotate_Left (input_a, input_b, output_a_rotated_left);
Rotate_Left ROL_top (input_a_top, input_b_top, rol_out);


//  mod    name             output          control  
    MUX16   TopMux_0        (
                            {rol_out [0],    //1111 control signal not used
                            ror_out [0],     //1110
                            sll_out [0],     //1101
                            srl_out [0],     //1100
                            xnor_out[0],     //1011
                            nand_out[0],     //1010 control signal not used
                            not_out [0],     //1001 control signal not used
                            nor_out [0],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,     		 //0110
                            1'b0,     		 //0101
                            mul_out [0],     //0100
                            rsb_out [0],     //0011
                            sub_out [0],     //0010
                            add_out [0],     //0001
                            1'b0},    		 //0000
                            output_top[0],
                            control
                            );

    MUX16   TopMux_1        (
                            {rol_out[1],     //1111 control signal not used
                            ror_out [1],     //1110
                            sll_out [1],     //1101
                            srl_out [1],     //1100
                            xnor_out[1],     //1011
                            nand_out[1],     //1010 control signal not used
                            not_out [1],     //1001 control signal not used
                            nor_out [1],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [1],     //0100
                            rsb_out [1],     //0011
                            sub_out [1],     //0010
                            add_out [1],     //0001
                            1'b0},     //1111
                            output_top[1],
                            control
                            );

    MUX16   TopMux_2        (
                            {rol_out[2],     //1111 control signal not used
                            ror_out [2],     //1110
                            sll_out [2],     //1101
                            srl_out [2],     //1100
                            xnor_out[2],     //1011
                            nand_out[2],     //1010 control signal not used
                            not_out [2],     //1001 control signal not used
                            nor_out [2],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [2],     //0100
                            rsb_out [2],     //0011
                            sub_out [2],     //0010
                            add_out [2],     //0001
                            1'b0},     //1111
                            output_top[2],
                            control
                            );

    MUX16   TopMux_3        (
                            {rol_out[3],    //1111 control signal not used
                            ror_out [3],     //1110
                            sll_out [3],     //1101
                            srl_out [3],     //1100
                            xnor_out[3],     //1011
                            nand_out[3],     //1010 control signal not used
                            not_out [3],     //1001 control signal not used
                            nor_out [3],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [3],     //0100
                            rsb_out [3],     //0011
                            sub_out [3],     //0010
                            add_out [3],     //0001
                            1'b0},     //1111
                            output_top[3],
                            control
                            );

    MUX16   TopMux_4        (
                            {rol_out[4],    //1111 control signal not used
                            ror_out [4],     //1110
                            sll_out [4],     //1101
                            srl_out [4],     //1100
                            xnor_out[4],     //1011
                            nand_out[4],     //1010 control signal not used
                            not_out [4],     //1001 control signal not used
                            nor_out [4],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [4],     //0100
                            rsb_out [4],     //0011
                            sub_out [4],     //0010
                            add_out [4],     //0001
                            1'b0},     //1111
                            output_top[4],
                            control
                            );                                                                                    

    MUX16   TopMux_5        (
                            {rol_out[5],    //1111 control signal not used
                            ror_out [5],     //1110
                            sll_out [5],     //1101
                            srl_out [5],     //1100
                            xnor_out[5],     //1011
                            nand_out[5],     //1010 control signal not used
                            not_out [5],     //1001 control signal not used
                            nor_out [5],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [5],     //0100
                            rsb_out [5],     //0011
                            sub_out [5],     //0010
                            add_out [5],     //0001
                            1'b0},     //1111
                            output_top[5],
                            control
                            );

    MUX16   TopMux_6        (
                            {rol_out[6],    //1111 control signal not used
                            ror_out [6],     //1110
                            sll_out [6],     //1101
                            srl_out [6],     //1100
                            xnor_out[6],     //1011
                            nand_out[6],     //1010 control signal not used
                            not_out [6],     //1001 control signal not used
                            nor_out [6],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [6],     //0100
                            rsb_out [6],     //0011
                            sub_out [6],     //0010
                            add_out [6],     //0001
                            1'b0},     //1111
                            output_top[6],
                            control
                            );

    MUX16   TopMux_7        (
                            {rol_out[7],    //1111 control signal not used
                            ror_out [7],     //1110
                            sll_out [7],     //1101
                            srl_out [7],     //1100
                            xnor_out[7],     //1011
                            nand_out[7],     //1010 control signal not used
                            not_out [7],     //1001 control signal not used
                            nor_out [7],     //1000 control signal not used
                            1'b0,            //0111
                            1'b0,            //0110
                            1'b0,            //0101
                            mul_out [7],     //0100
                            rsb_out [7],     //0011
                            sub_out [7],     //0010
                            add_out [7],     //0001
                            1'b0},     //1111
                            output_top[7],
                            control
                            );                                                        

endmodule

//Addition
module FADD1 
	(
	in1, 
	in2, 
	s, 
	cin, 
	cout
	); 
input  in1, in2, cin; //port declaration in1 and in2 are inputs a and b for the adder, cin is Carry in
output s, cout; //port dec S is sum and cout is carry out
wire   out1, out2, out3; //internal variables between gates
//using built in-gates, the following gate-level modeling arranges a 1-bit full adder
xor g1 (out1, in1, in2);
xor g2 (s, out1, cin);
and g3 (out2, out1, cin);
and g4 (out3, in1, in2);
or g5  (cout, out2, out3);
endmodule

module FADDSUB8
	(
	input_a, 
	input_b, 
	sum,
	sel, 
	//carry_in, 
	carry_out
	);
input 	[7:0] 	input_a, input_b;
//input 			carry_in;
input	[1:0]	sel; //if sel is 2'b01, sum = a+b; 2'b10, sum = a-b, 2'b11, sum = b-a. 
output 	[7:0] 	sum;
output 			carry_out;

wire [6:0] internal_carry;
wire [7:0] xor_input_a, xor_input_b;
wire not_sel, andselb, andsela; //not_sel = !sel[1], andselb = not_sel AND sel0, andsela = sel1 AND sel0. 

not (not_sel, sel[0]);
//and (andselb, not_sel, sel[0]);
and (andsela, sel[1], sel[0]);

xor xa1	(xor_input_a[0], andsela, input_a[0]);
xor xa2	(xor_input_a[1], andsela, input_a[1]);
xor xa3	(xor_input_a[2], andsela, input_a[2]);
xor xa4	(xor_input_a[3], andsela, input_a[3]);
xor xa5	(xor_input_a[4], andsela, input_a[4]);
xor xa6	(xor_input_a[5], andsela, input_a[5]);
xor xa7	(xor_input_a[6], andsela, input_a[6]);
xor xa8	(xor_input_a[7], andsela, input_a[7]); 

xor xb1	(xor_input_b[0], not_sel, input_b[0]);
xor xb2	(xor_input_b[1], not_sel, input_b[1]);
xor xb3	(xor_input_b[2], not_sel, input_b[2]);
xor xb4	(xor_input_b[3], not_sel, input_b[3]);
xor xb5	(xor_input_b[4], not_sel, input_b[4]);
xor xb6	(xor_input_b[5], not_sel, input_b[5]);
xor xb7	(xor_input_b[6], not_sel, input_b[6]);
xor xb8	(xor_input_b[7], not_sel, input_b[7]); 

FADD1 A1 (xor_input_a[0], 		xor_input_b[0],			sum[0], 		sel[1], 			internal_carry[0]);
FADD1 A2 (xor_input_a[1], 		xor_input_b[1],			sum[1], 		internal_carry[0], 	internal_carry[1]);
FADD1 A3 (xor_input_a[2], 		xor_input_b[2],			sum[2], 		internal_carry[1], 	internal_carry[2]);
FADD1 A4 (xor_input_a[3], 		xor_input_b[3],			sum[3], 		internal_carry[2], 	internal_carry[3]);
FADD1 A5 (xor_input_a[4], 		xor_input_b[4],			sum[4], 		internal_carry[3], 	internal_carry[4]);
FADD1 A6 (xor_input_a[5], 		xor_input_b[5],			sum[5], 		internal_carry[4], 	internal_carry[5]);
FADD1 A7 (xor_input_a[6], 		xor_input_b[6],			sum[6], 		internal_carry[5], 	internal_carry[6]);
FADD1 A8 (xor_input_a[7], 		xor_input_b[7],			sum[7], 		internal_carry[6], 	carry_out);

endmodule

/*
//Subtraction

module SUB1
	(
	in1,
	in2,
	bin,
	bout,
	diff
	);
input 	in1, in2, bin;
output 	diff, bout;

wire internal_not_1, internal_not_2, internal_xor, internal_and_1, internal_and_2;

xor subXOR1 (internal_xor, in1, in2);
not subNOT1 (internal_not_1, in1);
and subAND1 (internal_and_1, in2, internal_not_1);
xor subXOR2 (diff, internal_xor, bin);
not subNOT2 (internal_not_2, internal_xor);
and subAND2 (internal_and_2, bin, internal_not_2);
or 	subOR   (bout, internal_and_2, internal_and_1);
endmodule

module SUB8
	(
	input_a,
	input_b,
	borrow_in,
	borrow_out,
	difference
	);
input 	[7:0] 	input_a, input_b; 
input			borrow_in;
output			borrow_out;
output	[7:0]	difference;

wire	[6:0]	internal_borrow;
		
SUB1 S1 (input_a[0], input_b[0], borrow_in, 			internal_borrow[0], difference[0]);
SUB1 S2 (input_a[1], input_b[1], internal_borrow[0], 	internal_borrow[1], difference[1]);
SUB1 S3 (input_a[2], input_b[2], internal_borrow[1], 	internal_borrow[2], difference[2]);
SUB1 S4 (input_a[3], input_b[3], internal_borrow[2], 	internal_borrow[3], difference[3]);
SUB1 S5 (input_a[4], input_b[4], internal_borrow[3], 	internal_borrow[4], difference[4]);
SUB1 S6 (input_a[5], input_b[5], internal_borrow[4],	internal_borrow[5], difference[5]);
SUB1 S7 (input_a[6], input_b[6], internal_borrow[5], 	internal_borrow[6], difference[6]);
SUB1 S8 (input_a[7], input_b[7], internal_borrow[6], 	borrow_out,			difference[7]);


endmodule
*/
//Reverse Subtraction

//Multiplication

//FADD1 duplicate
/*module FADD1 (in1, in2, s, cin, cout); 
input  in1, in2, cin; //port declaration in1 and in2 are inputs a and b for the adder, cin is Carry in
output s, cout; //port dec S is sum and cout is carry out
wire   out1, out2, out3; //internal variables between gates
//using built in-gates, the following gate-level modeling arranges a 1-bit full adder
xor g1 (out1, in1, in2);
xor g2 (s, out1, cin);
and g3 (out2, out1, cin);
and g4 (out3, in1, in2);
or g5  (cout, out2, out3);

endmodule*/

//MUL MODULE
module JLAPANEMUL4 (inputa, inputb, Output_P_eq_ab); 
//using different naming convention for readability 
input [3:0] inputa, inputb;
output [7:0] Output_P_eq_ab;
wire [7:0] internal_x, internal_y, internal_z; // internal wires between ANDs and FADD, see //#
wire [8:0] carry;

assign internal_x[3] = 1'b0;

//inputs initial and
and (Output_P_eq_ab[0], inputa[0], inputb[0]);
and (internal_x[0], inputa[1], inputb[0]);
and (internal_x[1], inputa[2], inputb[0]);
and (internal_x[2], inputa[3], inputb[0]);
//group0 and+FADD 
and (internal_x[4], inputa[0], inputb[1]); //0, x wires go from AND gate to FADD module
and (internal_x[5], inputa[1], inputb[1]); //0
and (internal_x[6], inputa[2], inputb[1]); //0
and (internal_x[7], inputa[3], inputb[1]); //0

FADD1 A1 (internal_x[0],internal_x[4], Output_P_eq_ab[1], 1'b0, carry[0]); //0 internal_x[#] //wires are inputs
FADD1 A2 (internal_x[1],internal_x[5], internal_y[0], carry[0], carry[1]); //0 //internal_y[#] //wires are outputs to next set of FADDs
FADD1 A3 (internal_x[2],internal_x[6], internal_y[1], carry[1], carry[2]); //0
FADD1 A4 (internal_x[3],internal_x[7], internal_y[2], carry[2], internal_y[3]); //0

//group1 and+FADD 
and (internal_y[4], inputa[0], inputb[2]); //1 internal_y[#] wires are outputs to FADD1 B#
and (internal_y[5], inputa[1], inputb[2]); //1
and (internal_y[6], inputa[2], inputb[2]); //1
and (internal_y[7], inputa[3], inputb[2]); //1

FADD1 B1 (internal_y[0],internal_y[4], Output_P_eq_ab[2], 1'b0, carry[3]); //1
FADD1 B2 (internal_y[1],internal_y[5], internal_z[0], carry[3], carry[4]); //1
FADD1 B3 (internal_y[2],internal_y[6], internal_z[1], carry[4], carry[5]); //1
FADD1 B4 (internal_y[3],internal_y[7], internal_z[2], carry[5], internal_z[3]); //1

//group2 and+FADD
and (internal_z[4], inputa[0], inputb[3]); //2 internal_z[#] wires are outputs to FADD1 C#
and (internal_z[5], inputa[1], inputb[3]); //2
and (internal_z[6], inputa[2], inputb[3]); //2
and (internal_z[7], inputa[3], inputb[3]); //2

FADD1 C1 (internal_z[0], internal_z[4], Output_P_eq_ab[3], 1'b0, carry[6]); //2
FADD1 C2 (internal_z[1], internal_z[5], Output_P_eq_ab[4], carry[6], carry[7]); //2
FADD1 C3 (internal_z[2], internal_z[6], Output_P_eq_ab[5], carry[7], carry[8]); //2
FADD1 C4 (internal_z[3], internal_z[7], Output_P_eq_ab[6], carry[8], Output_P_eq_ab[7]);  //2

endmodule


//Bitwise NOR

module myNOR8 (input_a, input_b, output_ab_nor);

input 	[7:0]	input_a, input_b;

output 	[7:0]	output_ab_nor;

nor iNOR1 (output_ab_nor[0], input_a[0], input_b[0]);
nor iNOR2 (output_ab_nor[1], input_a[1], input_b[1]);
nor iNOR3 (output_ab_nor[2], input_a[2], input_b[2]);
nor iNOR4 (output_ab_nor[3], input_a[3], input_b[3]);
nor iNOR5 (output_ab_nor[4], input_a[4], input_b[4]);
nor iNOR6 (output_ab_nor[5], input_a[5], input_b[5]);
nor iNOR7 (output_ab_nor[6], input_a[6], input_b[6]);
nor iNOR8 (output_ab_nor[7], input_a[7], input_b[7]);

endmodule


//Bitwise NOT

module myNOT8 (input_b, output_b_NOT);

input 	[7:0]	input_b;

output 	[7:0]	output_b_NOT;

not iNOT1 (output_b_NOT[0], input_b[0]);
not iNOT2 (output_b_NOT[1], input_b[1]);
not iNOT3 (output_b_NOT[2], input_b[2]);
not iNOT4 (output_b_NOT[3], input_b[3]);
not iNOT5 (output_b_NOT[4], input_b[4]);
not iNOT6 (output_b_NOT[5], input_b[5]);
not iNOT7 (output_b_NOT[6], input_b[6]);
not iNOT8 (output_b_NOT[7], input_b[7]);

endmodule

//Bitwise NAND

module myNAND8 (input_a, input_b, output_ab_nand);

input 	[7:0]	input_a, input_b;

output 	[7:0]	output_ab_nand;

nand iNAND1 (output_ab_nand[0], input_a[0], input_b[0]);
nand iNAND2 (output_ab_nand[1], input_a[1], input_b[1]);
nand iNAND3 (output_ab_nand[2], input_a[2], input_b[2]);
nand iNAND4 (output_ab_nand[3], input_a[3], input_b[3]);
nand iNAND5 (output_ab_nand[4], input_a[4], input_b[4]);
nand iNAND6 (output_ab_nand[5], input_a[5], input_b[5]);
nand iNAND7 (output_ab_nand[6], input_a[6], input_b[6]);
nand iNAND8 (output_ab_nand[7], input_a[7], input_b[7]);

endmodule

//Bitwise XNOR

module myXNOR8 (input_a, input_b, output_ab_xnor);

input 	[7:0]	input_a, input_b;

output 	[7:0]	output_ab_xnor;

xnor iXNOR1 (output_ab_xnor[0], input_a[0], input_b[0]);
xnor iXNOR2 (output_ab_xnor[1], input_a[1], input_b[1]);
xnor iXNOR3 (output_ab_xnor[2], input_a[2], input_b[2]);
xnor iXNOR4 (output_ab_xnor[3], input_a[3], input_b[3]);
xnor iXNOR5 (output_ab_xnor[4], input_a[4], input_b[4]);
xnor iXNOR6 (output_ab_xnor[5], input_a[5], input_b[5]);
xnor iXNOR7 (output_ab_xnor[6], input_a[6], input_b[6]);
xnor iXNOR8 (output_ab_xnor[7], input_a[7], input_b[7]);

endmodule
// D-flip-flop should have been used for a SRL/SLL but the project required we select number of shifts from input_b_top [2:0], so not allowed to depend on clock.
// Probably should have implemented a counter to disable the DFFs instead of lots of nets and muxes.

//2-to-1 mux, this is directly from class notes


module MUX2 (i0, i1, sel, out); //your declaration determines how to put the port list when you make instance 
//input and output ports declaration
input i0, i1, sel;
output out;

//local variables
wire o1, o2, o3;

//build-in gate
not g1 (o1, sel);
and g2 (o2, i1, sel);
and g3 (o3, o1, i0);
or g4 (out, o2, o3);

endmodule

//8-to-1 mux, this is directly from class notes

module MUX8 (d0, d1, d2, d3, d4, d5, d6, d7, s0, s1, s2, y); 
//input and output ports declaration
input d0, d1, d2, d3, d4, d5, d6, d7, s0, s1, s2;
output y;

//local variables
wire o1, o2, o3, o4, o5, o6;

//make instance of MUX2
MUX2 g1 (d0, d1, s0, o1);
MUX2 g2 (d2, d3, s0, o2);
MUX2 g3 (d4, d5, s0, o3);
MUX2 g4 (d6, d7, s0, o4);
MUX2 g5 (o1, o2, s1, o5);
MUX2 g6 (o3, o4, s1, o6);
MUX2 g7 (o5, o6, s2, y); 

endmodule



//Shift Right or Left Logical
//shift right 8 is not allowed, but shift right 0 is allowed

module Shift_Right (
     input_a, 
     input_b, 
     output_a_shifted
     );

input 	[7:0]	input_a,
                input_b;
output	[7:0]	output_a_shifted;


wire     [7:0]   shift_right_one, 
                shift_right_two,
                shift_right_three,
                shift_right_four,
                shift_right_five,
                shift_right_six,
                shift_right_seven; //shift right 8 is not allowed, but shift right 0 is allowed

//wire    [2:0]   select;
//wire    [7:0]   outputwire;



assign shift_right_one[0] = input_a[1];
assign shift_right_one[1] = input_a[2];
assign shift_right_one[2] = input_a[3];
assign shift_right_one[3] = input_a[4];
assign shift_right_one[4] = input_a[5];
assign shift_right_one[5] = input_a[6];
assign shift_right_one[6] = input_a[7];
assign shift_right_one[7] = 1'b0;

assign shift_right_two[0] = input_a[2];
assign shift_right_two[1] = input_a[3];
assign shift_right_two[2] = input_a[4];
assign shift_right_two[3] = input_a[5];
assign shift_right_two[4] = input_a[6];
assign shift_right_two[5] = input_a[7];
assign shift_right_two[6] = 1'b0;
assign shift_right_two[7] = 1'b0;

assign shift_right_three[0] = input_a[3];
assign shift_right_three[1] = input_a[4];
assign shift_right_three[2] = input_a[5];
assign shift_right_three[3] = input_a[6];
assign shift_right_three[4] = input_a[7];
assign shift_right_three[5] = 1'b0;
assign shift_right_three[6] = 1'b0;
assign shift_right_three[7] = 1'b0;

assign shift_right_four[0] = input_a[4];
assign shift_right_four[1] = input_a[5];
assign shift_right_four[2] = input_a[6];
assign shift_right_four[3] = input_a[7];
assign shift_right_four[4] = 1'b0;
assign shift_right_four[5] = 1'b0;
assign shift_right_four[6] = 1'b0;
assign shift_right_four[7] = 1'b0;

assign shift_right_five[0] = input_a[5];
assign shift_right_five[1] = input_a[6];
assign shift_right_five[2] = input_a[7];
assign shift_right_five[3] = 1'b0;
assign shift_right_five[4] = 1'b0;
assign shift_right_five[5] = 1'b0;
assign shift_right_five[6] = 1'b0;
assign shift_right_five[7] = 1'b0;

assign shift_right_six[0] = input_a[6];
assign shift_right_six[1] = input_a[7];
assign shift_right_six[2] = 1'b0;
assign shift_right_six[3] = 1'b0;
assign shift_right_six[4] = 1'b0;
assign shift_right_six[5] = 1'b0;
assign shift_right_six[6] = 1'b0;
assign shift_right_six[7] = 1'b0;

assign shift_right_seven[0] = input_a[7];
assign shift_right_seven[1] = 1'b0;
assign shift_right_seven[2] = 1'b0;
assign shift_right_seven[3] = 1'b0;
assign shift_right_seven[4] = 1'b0;
assign shift_right_seven[5] = 1'b0;
assign shift_right_seven[6] = 1'b0;
assign shift_right_seven[7] = 1'b0;


MUX8 OUTPUT0MUX (input_a            [0], // if input_b [2:0] == 3'b000
                shift_right_one     [0], // 3'b001
                shift_right_two     [0], // 3'b010
                shift_right_three   [0], // 3'b011
                shift_right_four    [0], // 3'b100
                shift_right_five    [0], // 3'b101
                shift_right_six     [0], // 3'b110
                shift_right_seven   [0], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted[0]);

MUX8 OUTPUT1MUX (input_a            [1], // 3'b000
                shift_right_one     [1], // 3'b001
                shift_right_two     [1], // 3'b010
                shift_right_three   [1], // 3'b011
                shift_right_four    [1], // 3'b100
                shift_right_five    [1], // 3'b101
                shift_right_six     [1], // 3'b110
                shift_right_seven   [1], // 3'b111
                input_b[0],
                input_b[1], 
                input_b[2], 
                output_a_shifted[1]);

MUX8 OUTPUT2MUX (input_a            [2], // 3'b000
                shift_right_one     [2], // 3'b001
                shift_right_two     [2], // 3'b010
                shift_right_three   [2], // 3'b011
                shift_right_four    [2], // 3'b100
                shift_right_five    [2], // 3'b101
                shift_right_six     [2], // 3'b110
                shift_right_seven   [2], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted[2]);

MUX8 OUTPUT3MUX (input_a            [3], // 3'b000
                shift_right_one     [3], // 3'b001
                shift_right_two     [3], // 3'b010
                shift_right_three   [3], // 3'b011
                shift_right_four    [3], // 3'b100
                shift_right_five    [3], // 3'b101
                shift_right_six     [3], // 3'b110
                shift_right_seven   [3], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted[3]);

MUX8 OUTPUT4MUX (input_a            [4], // 3'b000
                shift_right_one     [4], // 3'b001
                shift_right_two     [4], // 3'b010
                shift_right_three   [4], // 3'b011
                shift_right_four    [4], // 3'b100
                shift_right_five    [4], // 3'b101
                shift_right_six     [4], // 3'b110
                shift_right_seven   [4], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted[4]);

MUX8 OUTPUT5MUX (input_a            [5], // 3'b000
                shift_right_one     [5], // 3'b001
                shift_right_two     [5], // 3'b010
                shift_right_three   [5], // 3'b011
                shift_right_four    [5], // 3'b100
                shift_right_five    [5], // 3'b101
                shift_right_six     [5], // 3'b110
                shift_right_seven   [5], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted[5]);

MUX8 OUTPUT6MUX (input_a            [6], // 3'b000
                shift_right_one     [6], // 3'b001
                shift_right_two     [6], // 3'b010
                shift_right_three   [6], // 3'b011
                shift_right_four    [6], // 3'b100
                shift_right_five    [6], // 3'b101
                shift_right_six     [6], // 3'b110
                shift_right_seven   [6], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2], 
                output_a_shifted[6]);

MUX8 OUTPUT7MUX (input_a            [7], // 3'b000
                shift_right_one     [7], // 3'b001
                shift_right_two     [7], // 3'b010
                shift_right_three   [7], // 3'b011
                shift_right_four    [7], // 3'b100
                shift_right_five    [7], // 3'b101
                shift_right_six     [7], // 3'b110
                shift_right_seven   [7], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted[7]);

endmodule


// Left Shifter, this is usually an array of DFF but designer struggled to handle unique outputs of a DFF array driven by a clock in time to submit,
// a requirement was to have the shifting amount determined by input_b [2:0] for this segment of the project.
module Shift_Left (
    input_a,
    input_b,
    output_a_shifted_left
    );

input 	[7:0]	input_a,
                input_b;
output	[7:0]	output_a_shifted_left;


wire     [7:0]   shift_left_one, 
                shift_left_two,
                shift_left_three,
                shift_left_four,
                shift_left_five,
                shift_left_six,
                shift_left_seven; //shift left 8 is not allowed, but shift left 0 is allowed


assign shift_left_one[0] = 1'b0;
assign shift_left_one[1] = input_a[0];
assign shift_left_one[2] = input_a[1];
assign shift_left_one[3] = input_a[2];
assign shift_left_one[4] = input_a[3];
assign shift_left_one[5] = input_a[4];
assign shift_left_one[6] = input_a[5];
assign shift_left_one[7] = input_a[6];

assign shift_left_two[0] = 1'b0;
assign shift_left_two[1] = 1'b0;
assign shift_left_two[2] = input_a[0];
assign shift_left_two[3] = input_a[1];
assign shift_left_two[4] = input_a[2];
assign shift_left_two[5] = input_a[3];
assign shift_left_two[6] = input_a[4];
assign shift_left_two[7] = input_a[5];

assign shift_left_three[0] = 1'b0;
assign shift_left_three[1] = 1'b0;
assign shift_left_three[2] = 1'b0;
assign shift_left_three[3] = input_a[0];
assign shift_left_three[4] = input_a[1];
assign shift_left_three[5] = input_a[2];
assign shift_left_three[6] = input_a[3];
assign shift_left_three[7] = input_a[4];

assign shift_left_four[0] = 1'b0;
assign shift_left_four[1] = 1'b0;
assign shift_left_four[2] = 1'b0;
assign shift_left_four[3] = 1'b0;
assign shift_left_four[4] = input_a[0];
assign shift_left_four[5] = input_a[1];
assign shift_left_four[6] = input_a[2];
assign shift_left_four[7] = input_a[3];

assign shift_left_five[0] = 1'b0;
assign shift_left_five[1] = 1'b0;
assign shift_left_five[2] = 1'b0;
assign shift_left_five[3] = 1'b0;
assign shift_left_five[4] = 1'b0;
assign shift_left_five[5] = input_a[0];
assign shift_left_five[6] = input_a[1];
assign shift_left_five[7] = input_a[2];

assign shift_left_six[0] = 1'b0;
assign shift_left_six[1] = 1'b0;
assign shift_left_six[2] = 1'b0;
assign shift_left_six[3] = 1'b0;
assign shift_left_six[4] = 1'b0;
assign shift_left_six[5] = 1'b0;
assign shift_left_six[6] = input_a[0];
assign shift_left_six[7] = input_a[1];

assign shift_left_seven[0] = 1'b0;
assign shift_left_seven[1] = 1'b0;
assign shift_left_seven[2] = 1'b0;
assign shift_left_seven[3] = 1'b0;
assign shift_left_seven[4] = 1'b0;
assign shift_left_seven[5] = 1'b0;
assign shift_left_seven[6] = 1'b0;
assign shift_left_seven[7] = input_a[0];


MUX8 OUTPUT0MUXleft (input_a       [0], // if input_b [2:0] == 3'b000
                shift_left_one     [0], // 3'b001
                shift_left_two     [0], // 3'b010
                shift_left_three   [0], // 3'b011
                shift_left_four    [0], // 3'b100
                shift_left_five    [0], // 3'b101
                shift_left_six     [0], // 3'b110
                shift_left_seven   [0], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted_left[0]);

MUX8 OUTPUT1MUXleft (input_a       [1], // 3'b000
                shift_left_one     [1], // 3'b001
                shift_left_two     [1], // 3'b010
                shift_left_three   [1], // 3'b011
                shift_left_four    [1], // 3'b100
                shift_left_five    [1], // 3'b101
                shift_left_six     [1], // 3'b110
                shift_left_seven   [1], // 3'b111
                input_b[0],
                input_b[1], 
                input_b[2], 
                output_a_shifted_left[1]);

MUX8 OUTPUT2MUXleft (input_a       [2], // 3'b000
                shift_left_one     [2], // 3'b001
                shift_left_two     [2], // 3'b010
                shift_left_three   [2], // 3'b011
                shift_left_four    [2], // 3'b100
                shift_left_five    [2], // 3'b101
                shift_left_six     [2], // 3'b110
                shift_left_seven   [2], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted_left[2]);

MUX8 OUTPUT3MUXleft (input_a       [3], // 3'b000
                shift_left_one     [3], // 3'b001
                shift_left_two     [3], // 3'b010
                shift_left_three   [3], // 3'b011
                shift_left_four    [3], // 3'b100
                shift_left_five    [3], // 3'b101
                shift_left_six     [3], // 3'b110
                shift_left_seven   [3], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted_left[3]);

MUX8 OUTPUT4MUXleft (input_a       [4], // 3'b000
                shift_left_one     [4], // 3'b001
                shift_left_two     [4], // 3'b010
                shift_left_three   [4], // 3'b011
                shift_left_four    [4], // 3'b100
                shift_left_five    [4], // 3'b101
                shift_left_six     [4], // 3'b110
                shift_left_seven   [4], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted_left[4]);

MUX8 OUTPUT5MUXleft (input_a       [5], // 3'b000
                shift_left_one     [5], // 3'b001
                shift_left_two     [5], // 3'b010
                shift_left_three   [5], // 3'b011
                shift_left_four    [5], // 3'b100
                shift_left_five    [5], // 3'b101
                shift_left_six     [5], // 3'b110
                shift_left_seven   [5], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted_left[5]);

MUX8 OUTPUT6MUXleft (input_a       [6], // 3'b000
                shift_left_one     [6], // 3'b001
                shift_left_two     [6], // 3'b010
                shift_left_three   [6], // 3'b011
                shift_left_four    [6], // 3'b100
                shift_left_five    [6], // 3'b101
                shift_left_six     [6], // 3'b110
                shift_left_seven   [6], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2], 
                output_a_shifted_left[6]);

MUX8 OUTPUT7MUXleft (input_a       [7], // 3'b000
                shift_left_one     [7], // 3'b001
                shift_left_two     [7], // 3'b010
                shift_left_three   [7], // 3'b011
                shift_left_four    [7], // 3'b100
                shift_left_five    [7], // 3'b101
                shift_left_six     [7], // 3'b110
                shift_left_seven   [7], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_shifted_left[7]);

endmodule


module Rotate_Right (
    input_a, 
    input_b, 
    output_a_rotated_right
    );

input 	[7:0]	input_a,
                input_b;
output	[7:0]	output_a_rotated_right;


wire     [7:0]   rotate_right_one, 
                rotate_right_two,
                rotate_right_three,
                rotate_right_four,
                rotate_right_five,
                rotate_right_six,
                rotate_right_seven; //rotate right 8 is not allowed, but rotate right 0 is allowed


assign rotate_right_one[0] = input_a[1];
assign rotate_right_one[1] = input_a[2];
assign rotate_right_one[2] = input_a[3];
assign rotate_right_one[3] = input_a[4];
assign rotate_right_one[4] = input_a[5];
assign rotate_right_one[5] = input_a[6];
assign rotate_right_one[6] = input_a[7];
assign rotate_right_one[7] = input_a[0];

assign rotate_right_two[0] = input_a[2];
assign rotate_right_two[1] = input_a[3];
assign rotate_right_two[2] = input_a[4];
assign rotate_right_two[3] = input_a[5];
assign rotate_right_two[4] = input_a[6];
assign rotate_right_two[5] = input_a[7];
assign rotate_right_two[6] = input_a[0];
assign rotate_right_two[7] = input_a[1];

assign rotate_right_three[0] = input_a[3];
assign rotate_right_three[1] = input_a[4];
assign rotate_right_three[2] = input_a[5];
assign rotate_right_three[3] = input_a[6];
assign rotate_right_three[4] = input_a[7];
assign rotate_right_three[5] = input_a[0];
assign rotate_right_three[6] = input_a[1];
assign rotate_right_three[7] = input_a[2];

assign rotate_right_four[0] = input_a[4];
assign rotate_right_four[1] = input_a[5];
assign rotate_right_four[2] = input_a[6];
assign rotate_right_four[3] = input_a[7];
assign rotate_right_four[4] = input_a[0];
assign rotate_right_four[5] = input_a[1];
assign rotate_right_four[6] = input_a[2];
assign rotate_right_four[7] = input_a[3];

assign rotate_right_five[0] = input_a[5];
assign rotate_right_five[1] = input_a[6];
assign rotate_right_five[2] = input_a[7];
assign rotate_right_five[3] = input_a[0];
assign rotate_right_five[4] = input_a[1];
assign rotate_right_five[5] = input_a[2];
assign rotate_right_five[6] = input_a[3];
assign rotate_right_five[7] = input_a[4];

assign rotate_right_six[0] = input_a[6];
assign rotate_right_six[1] = input_a[7];
assign rotate_right_six[2] = input_a[0];
assign rotate_right_six[3] = input_a[1];
assign rotate_right_six[4] = input_a[2];
assign rotate_right_six[5] = input_a[3];
assign rotate_right_six[6] = input_a[4];
assign rotate_right_six[7] = input_a[5];

assign rotate_right_seven[0] = input_a[7];
assign rotate_right_seven[1] = input_a[0];
assign rotate_right_seven[2] = input_a[1];
assign rotate_right_seven[3] = input_a[2];
assign rotate_right_seven[4] = input_a[3];
assign rotate_right_seven[5] = input_a[4];
assign rotate_right_seven[6] = input_a[5];
assign rotate_right_seven[7] = input_a[6];


MUX8 OUTPUT0MUXrotateright (input_a  [0], // if input_b [2:0] == 3'b000
                rotate_right_one     [0], // 3'b001
                rotate_right_two     [0], // 3'b010
                rotate_right_three   [0], // 3'b011
                rotate_right_four    [0], // 3'b100
                rotate_right_five    [0], // 3'b101
                rotate_right_six     [0], // 3'b110
                rotate_right_seven   [0], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_right[0]);

MUX8 OUTPUT1MUXrotateright (input_a  [1], // 3'b000
                rotate_right_one     [1], // 3'b001
                rotate_right_two     [1], // 3'b010
                rotate_right_three   [1], // 3'b011
                rotate_right_four    [1], // 3'b100
                rotate_right_five    [1], // 3'b101
                rotate_right_six     [1], // 3'b110
                rotate_right_seven   [1], // 3'b111
                input_b[0],
                input_b[1], 
                input_b[2], 
                output_a_rotated_right[1]);

MUX8 OUTPUT2MUXrotateright (input_a  [2], // 3'b000
                rotate_right_one     [2], // 3'b001
                rotate_right_two     [2], // 3'b010
                rotate_right_three   [2], // 3'b011
                rotate_right_four    [2], // 3'b100
                rotate_right_five    [2], // 3'b101
                rotate_right_six     [2], // 3'b110
                rotate_right_seven   [2], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_right[2]);

MUX8 OUTPUT3MUXrotateright (input_a  [3], // 3'b000
                rotate_right_one     [3], // 3'b001
                rotate_right_two     [3], // 3'b010
                rotate_right_three   [3], // 3'b011
                rotate_right_four    [3], // 3'b100
                rotate_right_five    [3], // 3'b101
                rotate_right_six     [3], // 3'b110
                rotate_right_seven   [3], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_right[3]);

MUX8 OUTPUT4MUXrotateright (input_a  [4], // 3'b000
                rotate_right_one     [4], // 3'b001
                rotate_right_two     [4], // 3'b010
                rotate_right_three   [4], // 3'b011
                rotate_right_four    [4], // 3'b100
                rotate_right_five    [4], // 3'b101
                rotate_right_six     [4], // 3'b110
                rotate_right_seven   [4], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_right[4]);

MUX8 OUTPUT5MUXrotateright (input_a  [5], // 3'b000
                rotate_right_one     [5], // 3'b001
                rotate_right_two     [5], // 3'b010
                rotate_right_three   [5], // 3'b011
                rotate_right_four    [5], // 3'b100
                rotate_right_five    [5], // 3'b101
                rotate_right_six     [5], // 3'b110
                rotate_right_seven   [5], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_right[5]);

MUX8 OUTPUT6MUXrotateright (input_a  [6], // 3'b000
                rotate_right_one     [6], // 3'b001
                rotate_right_two     [6], // 3'b010
                rotate_right_three   [6], // 3'b011
                rotate_right_four    [6], // 3'b100
                rotate_right_five    [6], // 3'b101
                rotate_right_six     [6], // 3'b110
                rotate_right_seven   [6], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2], 
                output_a_rotated_right[6]);

MUX8 OUTPUT7MUXrotateright (input_a  [7], // 3'b000
                rotate_right_one     [7], // 3'b001
                rotate_right_two     [7], // 3'b010
                rotate_right_three   [7], // 3'b011
                rotate_right_four    [7], // 3'b100
                rotate_right_five    [7], // 3'b101
                rotate_right_six     [7], // 3'b110
                rotate_right_seven   [7], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_right[7]);

endmodule

module Rotate_Left (
    input_a, 
    input_b, 
    output_a_rotated_left
    );

input 	[7:0]	input_a,
                input_b;
output	[7:0]	output_a_rotated_left;


wire     [7:0]   rotate_left_one, 
                rotate_left_two,
                rotate_left_three,
                rotate_left_four,
                rotate_left_five,
                rotate_left_six,
                rotate_left_seven; //rotate left 8 is not allowed, but rotate left 0 is allowed


assign rotate_left_one[0] = input_a[7];
assign rotate_left_one[1] = input_a[0];
assign rotate_left_one[2] = input_a[1];
assign rotate_left_one[3] = input_a[2];
assign rotate_left_one[4] = input_a[3];
assign rotate_left_one[5] = input_a[4];
assign rotate_left_one[6] = input_a[5];
assign rotate_left_one[7] = input_a[6];

assign rotate_left_two[0] = input_a[6];
assign rotate_left_two[1] = input_a[7];
assign rotate_left_two[2] = input_a[0];
assign rotate_left_two[3] = input_a[1];
assign rotate_left_two[4] = input_a[2];
assign rotate_left_two[5] = input_a[3];
assign rotate_left_two[6] = input_a[4];
assign rotate_left_two[7] = input_a[5];

assign rotate_left_three[0] = input_a[5];
assign rotate_left_three[1] = input_a[6];
assign rotate_left_three[2] = input_a[7];
assign rotate_left_three[3] = input_a[0];
assign rotate_left_three[4] = input_a[1];
assign rotate_left_three[5] = input_a[2];
assign rotate_left_three[6] = input_a[3];
assign rotate_left_three[7] = input_a[4];

assign rotate_left_four[0] = input_a[4];
assign rotate_left_four[1] = input_a[5];
assign rotate_left_four[2] = input_a[6];
assign rotate_left_four[3] = input_a[7];
assign rotate_left_four[4] = input_a[0];
assign rotate_left_four[5] = input_a[1];
assign rotate_left_four[6] = input_a[2];
assign rotate_left_four[7] = input_a[3];

assign rotate_left_five[0] = input_a[3];
assign rotate_left_five[1] = input_a[4];
assign rotate_left_five[2] = input_a[5];
assign rotate_left_five[3] = input_a[6];
assign rotate_left_five[4] = input_a[7];
assign rotate_left_five[5] = input_a[0];
assign rotate_left_five[6] = input_a[1];
assign rotate_left_five[7] = input_a[2];

assign rotate_left_six[0] = input_a[2];
assign rotate_left_six[1] = input_a[3];
assign rotate_left_six[2] = input_a[4];
assign rotate_left_six[3] = input_a[5];
assign rotate_left_six[4] = input_a[6];
assign rotate_left_six[5] = input_a[7];
assign rotate_left_six[6] = input_a[0];
assign rotate_left_six[7] = input_a[1];

assign rotate_left_seven[0] = input_a[1];
assign rotate_left_seven[1] = input_a[2];
assign rotate_left_seven[2] = input_a[3];
assign rotate_left_seven[3] = input_a[4];
assign rotate_left_seven[4] = input_a[5];
assign rotate_left_seven[5] = input_a[6];
assign rotate_left_seven[6] = input_a[7];
assign rotate_left_seven[7] = input_a[0];


MUX8 OUTPUT0MUXrotateleft (input_a  [0], // if input_b [2:0] == 3'b000
                rotate_left_one     [0], // 3'b001
                rotate_left_two     [0], // 3'b010
                rotate_left_three   [0], // 3'b011
                rotate_left_four    [0], // 3'b100
                rotate_left_five    [0], // 3'b101
                rotate_left_six     [0], // 3'b110
                rotate_left_seven   [0], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_left[0]);

MUX8 OUTPUT1MUXrotateleft (input_a  [1], // 3'b000
                rotate_left_one     [1], // 3'b001
                rotate_left_two     [1], // 3'b010
                rotate_left_three   [1], // 3'b011
                rotate_left_four    [1], // 3'b100
                rotate_left_five    [1], // 3'b101
                rotate_left_six     [1], // 3'b110
                rotate_left_seven   [1], // 3'b111
                input_b[0],
                input_b[1], 
                input_b[2], 
                output_a_rotated_left[1]);

MUX8 OUTPUT2MUXrotateleft (input_a  [2], // 3'b000
                rotate_left_one     [2], // 3'b001
                rotate_left_two     [2], // 3'b010
                rotate_left_three   [2], // 3'b011
                rotate_left_four    [2], // 3'b100
                rotate_left_five    [2], // 3'b101
                rotate_left_six     [2], // 3'b110
                rotate_left_seven   [2], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_left[2]);

MUX8 OUTPUT3MUXrotateleft (input_a  [3], // 3'b000
                rotate_left_one     [3], // 3'b001
                rotate_left_two     [3], // 3'b010
                rotate_left_three   [3], // 3'b011
                rotate_left_four    [3], // 3'b100
                rotate_left_five    [3], // 3'b101
                rotate_left_six     [3], // 3'b110
                rotate_left_seven   [3], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_left[3]);

MUX8 OUTPUT4MUXrotateleft (input_a  [4], // 3'b000
                rotate_left_one     [4], // 3'b001
                rotate_left_two     [4], // 3'b010
                rotate_left_three   [4], // 3'b011
                rotate_left_four    [4], // 3'b100
                rotate_left_five    [4], // 3'b101
                rotate_left_six     [4], // 3'b110
                rotate_left_seven   [4], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_left[4]);

MUX8 OUTPUT5MUXrotateleft (input_a  [5], // 3'b000
                rotate_left_one     [5], // 3'b001
                rotate_left_two     [5], // 3'b010
                rotate_left_three   [5], // 3'b011
                rotate_left_four    [5], // 3'b100
                rotate_left_five    [5], // 3'b101
                rotate_left_six     [5], // 3'b110
                rotate_left_seven   [5], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_left[5]);

MUX8 OUTPUT6MUXrotateleft (input_a  [6], // 3'b000
                rotate_left_one     [6], // 3'b001
                rotate_left_two     [6], // 3'b010
                rotate_left_three   [6], // 3'b011
                rotate_left_four    [6], // 3'b100
                rotate_left_five    [6], // 3'b101
                rotate_left_six     [6], // 3'b110
                rotate_left_seven   [6], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2], 
                output_a_rotated_left[6]);

MUX8 OUTPUT7MUXrotateleft (input_a  [7], // 3'b000
                rotate_left_one     [7], // 3'b001
                rotate_left_two     [7], // 3'b010
                rotate_left_three   [7], // 3'b011
                rotate_left_four    [7], // 3'b100
                rotate_left_five    [7], // 3'b101
                rotate_left_six     [7], // 3'b110
                rotate_left_seven   [7], // 3'b111
                input_b[0],
                input_b[1],
                input_b[2],
                output_a_rotated_left[7]);

endmodule

// 12 to one mux

module MUX16 (
        mux16_input,
        mux16_output,
        mux16_control
        );
input   [15:0]  mux16_input;
input   [3:0]   mux16_control;

output          mux16_output;

wire    [7:0]   mux16_internal_L0;  // internal variables wiring previous mux2 to next mux2, layer 0
wire    [3:0]   mux16_internal_L1;  // internal variables wiring previous mux2 to next mux2, layer 1
wire    [1:0]   mux16_internal_L2;  // internal variables wiring previous mux2 to next mux2, layer 2

MUX2 MUX16_L0_0         (mux16_input[0],    mux16_input[1],     mux16_control[0],   mux16_internal_L0[0]);
MUX2 MUX16_L0_1         (mux16_input[2],    mux16_input[3],     mux16_control[0],   mux16_internal_L0[1]);
MUX2 MUX16_L0_2         (mux16_input[4],    mux16_input[5],     mux16_control[0],   mux16_internal_L0[2]);
MUX2 MUX16_L0_3         (mux16_input[6],    mux16_input[7],     mux16_control[0],   mux16_internal_L0[3]);
MUX2 MUX16_L0_4         (mux16_input[8],    mux16_input[9],     mux16_control[0],   mux16_internal_L0[4]);
MUX2 MUX16_L0_5         (mux16_input[10],   mux16_input[11],    mux16_control[0],   mux16_internal_L0[5]);
MUX2 MUX16_L0_6         (mux16_input[12],   mux16_input[13],    mux16_control[0],   mux16_internal_L0[6]);
MUX2 MUX16_L0_7         (mux16_input[14],   mux16_input[15],    mux16_control[0],   mux16_internal_L0[7]);

MUX2 MUX16_L1_0         (mux16_internal_L0[0],  mux16_internal_L0[1],   mux16_control[1],   mux16_internal_L1[0]);
MUX2 MUX16_L1_1         (mux16_internal_L0[2],  mux16_internal_L0[3],   mux16_control[1],   mux16_internal_L1[1]);
MUX2 MUX16_L1_2         (mux16_internal_L0[4],  mux16_internal_L0[5],   mux16_control[1],   mux16_internal_L1[2]);
MUX2 MUX16_L1_3         (mux16_internal_L0[6],  mux16_internal_L0[7],   mux16_control[1],   mux16_internal_L1[3]);

MUX2 MUX16_L2_0         (mux16_internal_L1[0],  mux16_internal_L1[1],   mux16_control[2],   mux16_internal_L2[0]);
MUX2 MUX16_L2_1         (mux16_internal_L1[2],  mux16_internal_L1[3],   mux16_control[2],   mux16_internal_L2[1]);

MUX2 MUX16_outputMUX2   (mux16_internal_L2[0],  mux16_internal_L2[0],   mux16_control[3],   mux16_output);

endmodule
